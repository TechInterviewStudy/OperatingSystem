## 페이지 교체 알고리즘에 대해 설명해 주세요.

> 운영체제가 물리 메모리에 없는 페이지를 요청할 때, 새로운 페이지를 불러오기 위해 기존 페이지를 제거하는 방식을 결정하는 알고리즘

### 종류
- FIFO (First-In, First-Out)
  - 가장 먼저 들어온 페이지를 제거하는 방식
- LRU (Least Recently Used)
  - 가장 오랫동안 사용되지 않은 페이지를 제거하는 방식
  - 캐시 효율이 높지만, 구현 비용이 큼
- LFU (Least Frequently Used)
  - 가장 적게 사용된 페이지를 제거
  - 오래된 페이지도 참조 횟수가 많으면 유지
- OPT (Optimal Page Replacement, Belady’s Algorithm)
  - 가장 나중에 참조될 페이지를 제거하는 방식 (이론적으로 가장 효율적이지만 구현 불가능)
- Clock (Second-Chance Algorithm)
  - FIFO 개선, `사용 비트(Reference Bit)`를 체크하여 페이지를 제거

## LRU 알고리즘은 어떤 특성을 이용한 알고리즘이라고 할 수 있을까요?

> 지역성(Locality) 원리를 이용한 알고리즘

### 지역성
- 지역성(Locality)이란 기억장치 내의 정보를 균일하게 Access하는 것이 아닌 어느 한 순간에 특정 부분을 집중적으로 참조하는 특성

- 시간 지역성(Temporal Locality)

  최근에 사용된 데이터가 다시 사용될 가능성이 높음

- 공간 지역성(Spatial Locality)

  사용된 데이터 근처의 데이터가 곧 사용될 가능성이 높음

- LRU는 시간 지역성을 활용하여, 가장 오랫동안 사용되지 않은 페이지를 제거하는 방식

## LRU 알고리즘을 구현한다면, 어떻게 구현할 수 있을까요?

> 해시 + 연결 리스트
- 캐시가 가득 찼을때, 가장 오랫동안 참조되지 않은 페이지를 찾아서 없애는 과정이 필요
- Cache Hit
  - CPU가 참조하고자 하는 메모리가 캐시에 존재하는 경우
  - 데이터가 캐시에 존재하는 경우, 해당 데이터를 최근에 사용된 위치로 갱신
- Cache Miss
  - CPU가 참조하고자 하는 메모리가 캐시에 존재하지 않는 경우
  - 가장 오래된 데이터를 제거하고, 새로운 데이터를 추가

## LRU 알고리즘의 단점을 설명해 주세요. 이를 해결할 수 있는 대안에 대해서도 설명해 주세요.
- 메모리의 추가 공간(오버 헤드)이 필요
- 구현이 복잡하고 오버헤드 발생
  - 캐시가 클 경우, 최근 사용된 데이터를 갱신하는 연산이 부담될 수 있음
  - 대안
    - CLOCK 알고리즘
      - LRU보다 간단한 방식으로, 페이지를 원형 큐에 저장하고 참조 비트를 사용하여 교체
- 캐시 크기가 작을 경우, 순차 접근(Looping Access) 문제 발생
  - 캐시 미스(Cache Miss)가 증가하여 성능 저하
- 페이지가 동등하게 취급되어, 중요 데이터가 밀려나는 문제
  - 모든 페이지가 동일한 가중치를 가짐 &rarr; 자주 사용되는 중요한 데이터도 교체될 수 있음
  - 대안
    - LFU(Least Frequently Used) 알고리즘
      - 사용 빈도를 기반으로 교체할 페이지를 결정