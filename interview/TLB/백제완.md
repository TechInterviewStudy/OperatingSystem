## TLB는 무엇인가요?
> 가상 주소를 실제 주소로 변환하는 캐시


## TLB를 쓰면 왜 빨라지나요?
- 페이지 테이블을 매번 접근하지 않아도 됨
  - 메모리 접근 시, TLB를 먼저 확인 &rarr; TLB Hit 발생 시 빠르게 변환
- 캐싱된 변환 정보를 사용하여 성능 향상
  - 페이지 테이블을 직접 참조하면 여러 단계 접근이 필요하지만, TLB는 한 번의 접근으로 해결

## MMU가 무엇인가요?
> MMU (Memory Management Unit) : 가상 주소를 실제 주소로 변환하는 하드웨어 장치
 - TLB를 포함하며, 변환이 실패하면 페이지 테이블을 참조하여 변환 수행


## TLB와 MMU는 어디에 위치해 있나요
### MMU
- CPU 내부
### TLB
- MMU 내부 &rarr; CPU 내부 (L1, L2 캐시처럼 빠른 접근이 필요함)

## 코어가 여러개라면, TLB는 어떻게 동기화 할 수 있을까요?

## TLB 관점에서, Context Switching 발생 시 어떤 변화가 발생하는지 설명해 주세요.

- 기존 프로세스의 TLB 무효화 (Flush TLB)

  - 다른 프로세스로 전환되면, 이전 프로세스의 주소 변환 정보는 더 이상 유효하지 않음
  - 새로운 프로세스의 페이지 테이블을 로드해야 하므로, 기존 TLB 엔트리는 무효화(Flush)됨
  - TLB Miss 발생률 증가 → 성능 저하 

- ASID (Address Space Identifier) 활용 (TLB 유지 가능)

  - 최신 CPU는 ASID를 사용하여 프로세스별 TLB 엔트리를 구분
  - 같은 ASID를 가진 프로세스는 TLB를 유지할 수 있음
  - Context Switching 비용 감소 효과

- Kernel TLB는 유지 (커널 페이지는 공통으로 유지됨)
  - 커널 코드 영역(TLB)은 프로세스 간 공유
  - 사용자 공간(유저 프로세스)만 TLB에서 무효화됨




