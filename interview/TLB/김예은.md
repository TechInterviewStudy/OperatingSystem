- TLB는 무엇인가요?
  - TLB는 가상 주소를 물리 주소로 변환하는 과정에서 최근 변환된 페이지 정보를 캐싱하는 고속 버퍼입니다. 
  - CPU가 메모리 접근 시 MMU를 통해 변환됭어야 하는데, 매번 페이지 테이블을 조회하면 성능이 저하되므로 자주 사용하는 변환 결과를 TLB에 저장해서 속도를 높입니다. 
----
- TLB를 쓰면 왜 빨라지나요?
  - 메모리 접근 시 주소 변환 과정에서의 오버헤드를 줄일 수 있기 때문입니다. 
    - 보통 가상 주소 → 물리 주소 변환은 페이지 테이블을 참조해야 해서 메모리 접근이 필요
    - 하지만 TLB에 최근 변환된 주소가 저장되어 있다면, 메모리 접근 없이 즉시 변환이 가능 
    - 캐시처럼 동작해서 TLB Hit율이 높으면 메모리 접근 속도가 획기적으로 빨라짐.
----
- MMU가 무엇인가요?
  - **MMU(Memory Management Unit)**는 가상 주소를 물리 주소로 변환하는 하드웨어 장치입니다. 
----
- TLB와 MMU는 어디에 위치해 있나요?
  - TLB는 CPU 내부에 있는 고속 캐시로, L1/L2 캐시처럼 CPU 코어별로 존재합니다. 
  - MMU는 CPU 내부 또는 메모리 컨트롤러와 연결된 위치에 존재하며, TLB를 활용해 주소 변환을 수행합니다. 
-----
- 코어가 여러개라면, TLB는 어떻게 동기화 할 수 있을까요?
  - 각 코어가 자신만의 TLB를 갖고 있습니다. 
    - 만약 한 코어가 페이지 테이블을 수정했다면, 다른 코어의 TLB에 저장된 정보가 무효화될 수도 있습니다.
  - 이를 해결하기 위해 TLB Shootdown 기법을 사용
    - IPI (Inter-Processor Interrupt) 기반 동기화
       - 변경 감지 -> 해당 페이지의 TLB를 무효화 하라는 요청 보냄 -> (다른 코어의 TLB에서) TLB flush -> 응답 대기, 업데이트
------
- TLB 관점에서, Context Switching 발생 시 어떤 변화가 발생하는지 설명해 주세요.
  - Context Switching이 일어나면 프로세스의 주소 공간이 변경되므로, 기존 TLB 정보가 무효화될 가능성이 있습니다. 
    - 일반적으로 새로운 프로세스의 주소 공간과 기존 프로세스의 주소 공간이 다름 
    - 따라서 이전 프로세스의 TLB 엔트리는 쓸모없어질 가능성이 크고, TLB를 비워야 함. (= TLB Flush). 
    - 하지만 일부 시스템에서는 **Process-Specific Tag 즉, ASID, Address Space Identifier**를 사용해서, TLB 전체를 무효화하지 않고 ASID만 변경하여 오버헤드를 줄이기도 함 
    - TLB Flush가 발생하면, 초기에는 TLB Miss율이 증가하지만, 시간이 지나면 다시 캐시가 채워짐.