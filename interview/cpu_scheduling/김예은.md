- **프로세스 스케줄링 알고리즘에는 어떤 것들이 있나요?**
    - FIFO(선입선출), SJF(Shortest Job First), 우선순위 스케쥴링, RR(Round Robin), Multi-level queue, Multi-level feedback queue 등이 있습니다.
----
- **RR을 사용할 때, Time Slice에 따른 trade-off를 설명해 주세요.**
    - Time slice가 너무 **긴** 경우
        - FIFO와 유사해질 수 있습니다.
        - 실행 시간이 긴 프로세스가 짧은 프로세스를 지연시킬 수 있습니다.
        - 하지만, 컨텍스트 스위칭이 감소하므로 오버헤드가 줄어든다는 장점도 있습니다.
    - Time slice가 너무 **짧은** 경우
        - 빠른 응답시간을 가져 인터렉티브한 시스템에 유리합니다.
        - 하지만, 컨텍스트 스위칭이 너무 자주 발생하므로 오버헤드가 증가한다는 단점이 있습니다.
----
- **싱글 스레드 CPU 에서 상시로 돌아가야 하는 프로세스가 있다면, 어떤 스케쥴링 알고리즘을 사용하는 것이 좋을까요? 또 왜 그럴까요?**
    - 싱글 스레드 CPU에서 상시 돌아가야 하는 프로세스가 있다면, **RR스케줄링** 기법을 사용하는 것이 적합합니다.
    - 왜냐하면, 다른 알고리즘에 비해 RR은 특정 시간마다 **다른 프로세스들에게도 실행의 기회**를 주면서 상시 돌아가야하는 프로세스의 **지속적인 실행을 보장**하기 때문입니다.
----
- **동시성과 병렬성의 차이에 대해 설명해 주세요.**
    - 동시성은 여러 작업을 번갈아 가면서 실행하는 것을 의미합니다. (싱글 코어에서도 가능)
    - 병렬성은 여러 작업이 동시에 실행되는 것을 의미합니다. (멀티 코어 필요)
----
- **타 스케쥴러와 비교하여, Multi-level Feedback Queue는 어떤 문제점들을 해결한다고 볼 수 있을까요?**
    - 먼저, 이 스케줄링 방식은 SJF의 **기아 문제를 해결**해줍니다. Aging이라는 기법이 사용 되는데, 너무 오랬동안 기다려 방치되는 프로세스를 없애기 위해 시간 흐름에 따라 우선순위를 조정(aging)하여 기아 문제를 해결할 수 있습니다.
    - 다음으로, FIFO의 긴 작업이 **짧은 작업을 지연시키는 문제를 해결**해줍니다. 이 스케줄링은 빠른 작업의 우선순위가 높아 먼저 처리할 수 있습니다.
----
- **FIFO 스케쥴러는 정말 쓸모가 없는 친구일까요? 어떤 시나리오에 사용하면 좋을까요?**
    - 해당 스케줄링 **공정성**을 중요시하는 기법입니다.
    - 매우 단순하게 구현 가능하므로 작업시간이 비슷하고, 우선순위가 동등한 작업들을 처리하는 간단한 시스템에서 사용될 수 있습니다.
    - 예를 들면, **배치 작업**이 있습니다.
----
- **우리는 스케줄링 알고리즘을 "프로세스" 스케줄링 알고리즘이라고 부릅니다. 스레드는 다른 방식으로 스케줄링을 하나요?**
    - 프로세스와 스레드 스케줄링은 개념적으로 비슷합니다.
    - | 항목 | 프로세스 스케줄링 | 스레드 스케줄링 |
      | --- | --- | --- |
      | 관리 주체 | 운영체제(OS) | 운영체제(OS) + 유저 레벨 |
      | 유저/커널 모드 고려? | ❌ 고려 안 함 | ✅ 고려 필요 (유저/커널 스레드에 따라 다름) |
      | 목표 | 어떤 프로세스를 실행할지 결정 | 어떤 스레드를 실행할지 결정 |
      | 대표 알고리즘 | RR, SJF, MLFQ 등 | 1:1, N:1, M:N 모델 |
----
- **유저 스레드와 커널 스레드의 스케쥴링 알고리즘은 똑같을까요?**
    - 아니오, 각자 다른 방식으로 스케줄링됩니다.
    - **유저 스레드**: 사용자 레벨 라이브러리에 의해 스케줄링
        - 운영체제는 **하나의 프로세스로 인식** (1:1, N:1, M:N 모델)
        - CPU 스케줄링에 영향을 받지 않음

      | 모델 | 설명 | 장점 | 단점 | 예제 |
      | --- | --- | --- | --- | --- |
      | **1:1 모델** | 유저 스레드 1개 ↔ 커널 스레드 1개 | 멀티코어 활용 가능, 블록킹 문제 없음 | 커널 리소스 많이 사용, 컨텍스트 스위칭 오버헤드 | Linux, Windows (현대적 OS) |
      | **N:1 모델** | 여러 유저 스레드 ↔ 하나의 커널 스레드 | 컨텍스트 스위칭 빠름, 자원 절약 | 블록킹 문제 발생, 병렬 처리 불가능 | Green Threads (Java) |
      | **M:N 모델** | 여러 유저 스레드 ↔ 여러 커널 스레드 | 유연한 멀티스레딩, 리소스 최적화 | 구현 복잡함, 운영체제마다 지원 여부 다름 | Solaris, 일부 POSIX Thread |
      
    - **커널 스레드**: 운영체제 커널에 의해 직접 스케줄링
        - 각 스레드가 **독립적으로 스케줄링**됨 (1:1 모델 - 유저 스레드와 커널 스레드가 1개씩 짝)
        - 운영체제의 CPU 스케줄링 영향을 받음
