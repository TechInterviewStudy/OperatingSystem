## 프로그램이 컴파일 되어, 실행되는 과정을 간략하게 설명해 주세요.
> 코드를 작성하고 컴파일하며, 링커를 통해 연결 후 로더로 로드하여 실행

1. 컴파일 및 링킹 단계

    소스 코드를 컴파일러가 번역하여 오브젝트 파일을 생성하고, 링커가 여러 오브젝트 파일과 라이브러리를 하나의 실행 파일로 결합합니다.
2. 로딩 및 실행 단계

    운영체제의 로더가 실행 파일을 메모리에 적재하고 초기화한 후, CPU가 이를 실행하여 프로그램이 동작하게 됩니다.

## 링커와, 로더의 차이에 대해 설명해 주세요.
### 링커
- 역할
    - 여러 개의 오브젝트 파일과 라이브러리를 하나의 실행 파일로 결합
    - 서로 다른 파일에 정의된 함수나 변수를 참조할 때, 올바른 메모리 주소를 할당하고 연결해주는 작업(심볼 해결)을 수행
- 작동 시점
    - 컴파일 후, 실행 파일이 생성되기 전에 작동합니다.
- 주요 기능
    - `정적 링킹` : 실행 가능한 목적 파일을 만들 때 프로그램에서 사용하는 모든 라이브러리 모듈을 복사하는 방식
    - `동적 링킹` :  해당 모듈의 주소만을 가지고 있다가, 런타임에 실행 파일과 라이브러리가 메모리에 위치될 때 해당 모듈의 주소로 가서 필요한 것을 들고 오는 방식

### 로더
- 역할
    - 실행 파일을 메모리에 적재하고, 실행 가능한 상태로 초기화
    - 주소 재배치, 동적 라이브러리 연결 등 실행 환경 설정을 수행
- 작동 시점
    - 프로그램 실행 시, 운영체제가 실행 파일을 로드할 때 작동
- 순서
    1. Allocation(할당)
    2. Linking(연결)
    3. Relocation(재배치)
    4. Loading(적재)
- 주요 기능
    - 실행 파일을 분석하여, 코드, 데이터, 스택, 힙 등의 영역을 메모리에 할당
    - 주소 재배치 작업을 통해 실행 파일 내의 상대 주소들을 실제 메모리 주소에 맞게 수정
    - 필요에 따라 동적 라이브러리를 메모리에 올려 연결

### 차이점
링킹은 여러 개의 오브젝트 파일과 라이브러리를 하나의 실행 파일로 결합하는 작업으로, 로딩은 실행 파일을 메모리에 적재하여 실행 가능한 상태로 초기화하는 과정

## 컴파일 언어와 인터프리터 언어의 차이에 대해 설명해 주세요.
### 컴파일 언어
>  C, C++, Go 등
- 소스코드를 한 번에 기계어로 번역하여 실행 파일을 생성 &rarr; 빠르게 실행
- 컴파일러는 전체 소스코드를 변환 한 뒤 에러를 보고 &rarr; 컴파일 단계에서 에러 확인 가능
- 코드를 수정하면 다시 컴파일해야 함
- 최적화가 잘 이루어져 속도가 빠름
- 다른 시스템에서는 실행되지 않는 경우가 있음

### 인터프리터 언어
> Pythone, JavaScript 등등
- 추가적인 메모리를 사용하지 않음
- 소스코드를 한 줄씩 해석하며 실행 &rarr; 컴파일러에 비해 느리다.
- 프로그램 실행 시에 해석되므로 디버깅에 용이
- 플랫폼 독립성이 높음
- 개발 및 테스트가 빠름

## JIT에 대해 설명해 주세요.
> JIT(Just-In-Time) 컴파일

프로그램 실행 중(런타임)에 인터프리터 방식으로 실행되는 코드 또는 중간 코드(예: 바이트코드)를 기계어로 동적으로 변환하여 실행 속도를 높이는 기술
- 처음에는 인터프리터 방식으로 실행하다가, 반복 실행되거나 성능에 민감한 부분을 감지하면 해당 부분을 기계어로 컴파일하여 실행 속도를 높임 &rarr; `캐싱`
- 초기 실행 시에는 인터프리터의 유연성을 가지고, 필요한 부분만 컴파일하여 실행 효율성을 동시에 확보
### 사용 예
- `Java` :  HotSpot JVM은 자주 실행되는 바이트코드 부분을 JIT 컴파일하여 최적화된 기계어 코드를 생성

## 본인이 사용하는 언어는, 어떤식으로 컴파일 및 실행되는지 설명해 주세요.

>  Java는 소스 코드 → 바이트코드 변환(컴파일) → JVM에 의한 클래스 로딩 및 검증 → 인터프리터/ JIT 컴파일을 통한 실행의 과정을 거쳐 프로그램을 실행

1. 컴파일 단계
    - 개발자가 작성한 `.java 파일(소스 코드)`을 `javac` 컴파일러가 컴파일하여 `.class` 파일(바이트코드)로 변환
    - 이 바이트코드는 플랫폼에 독립적이며, JVM에서 실행될 수 있도록 설계되어 있음음
2. 실행 단계
    - 클래스 로더(Class Loader)
        - JVM이 시작될 때, 필요한 `.class` 파일들을 메모리에 적재
    - 바이트코드 검증 및 초기화
        - JVM은 적재된 바이트코드를 검증하며, 클래스 간의 연결과 초기화를 수행
    - 실행
        - 초기에는 인터프리터가 바이트코드를 한 줄씩 해석하며 실행행
        - 반복적으로 실행되는 코드 블록은 `JIT(Just-In-Time)` 컴파일러에 의해 기계어로 변환되어 최적화

## 우리는 흔히 fork(), exec() 시스템 콜을 사용하여 프로세스를 적재할 수 있다고 배웠습니다. 로더의 역할은 이 시스템 콜과 상관있는 걸까요? 아니면 다른 방식으로 프로세스를 적재할 수 있는 건가요?
`fork()`로 새 프로세스를 생성한 후, 자식 프로세스에서 `exec()`를 호출하여 로더가 실행 파일을 메모리에 적재하고 실행함