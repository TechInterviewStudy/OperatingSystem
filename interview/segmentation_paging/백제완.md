## 세그멘테이션과 페이징의 차이점은 무엇인가요?
> 페이징은 고정된 크기로 나누고, 세그멘테이션은 논리적 의미 단위로 나눔

|구분|페이징(Paging)|세그멘테이션(Segmentation)|
|-|-|-|
|메모리 할당 단위|고정 크기의 `페이지`|가변 크기의 `세그먼트`|
|주소 변환 방식|페이지 테이블 사용|세그먼트 테이블 사용|
|단편화 문제|내부 단편화 발생 가능|외부 단편화 발생 가능|
|주소 구조|페이지 번호 + 오프셋|세그먼트 번호 + 오프셋|
|메모리 관리 방식|물리적 크기에 초점|논리적 구조에 초점|

## 페이지와 프레임의 차이에 대해 설명해 주세요.
> 페이지는 가상 메모리의 논리적 단위, 프레임은 물리 메모리의 할당 단위
- 페이지(Page): 가상 메모리를 일정한 크기로 나눈 논리적인 단위
- 프레임(Frame): 물리 메모리(RAM)를 페이지와 동일한 크기로 나눈 단위

## 내부 단편화와, 외부 단편화에 대해 설명해 주세요.
> 내부 단편화는 페이지 크기보다 작은 데이터로 인한 낭비, 외부 단편화는 메모리 공간 조각으로 인해 큰 프로세스를 할당하지 못하는 문제

|구분|내부 단편화(Internal Fragmentation)|외부 단편화 (External Fragmentation)|
|-|-|-|
|발생 원인|고정된 크기의 페이지가 프로세스 크기와 맞지 않음|가변 크기 세그먼트 사용 시 남는 메모리 조각 발생|
|해결 방법|페이지 크기 조정 또는 세그멘테이션 사용|페이징 기법 적용(세그먼트 내에서도 페이징)|

## 페이지에서 실제 주소를 어떻게 가져올 수 있는지 설명해 주세요.
> 페이지 테이블을 이용해 페이지 번호를 프레임 번호로 변환한 후, 오프셋을 더해 실제 주소를 찾음
- 페이지 테이블 조회는 느릴 수 있기 때문에 TLB(Translation Lookaside Buffer)라는 캐시 메모리를 활용하여 속도를 높임
## 어떤 주소공간이 있을 때, 이 공간이 수정 가능한지 확인할 수 있는 방법이 있나요?
> 페이지 테이블의 속성 비트(R/W/X)와 MMU를 이용하여 해당 주소 공간이 수정 가능한지 확인
- 페이지 테이블의 `보호 비트(Protection Bits)` 또는 메모리 속성 정보를 확인
    - `W(Write) 비트`가 1로 설정되어 있는지 확인