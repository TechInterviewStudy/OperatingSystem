# 프로세스

## 컨텍스트 스위칭

### 프로세스와 스레드는 컨텍스트 스위칭이 발생했을 때 어떤 차이가 있을까요?
프로세스는 진행하던 모든 정보를 메모리에 올리고 스위칭되는 큰 오버헤드가 있지만, 스레드는 하나의 프로세스 안에서 진행되는 스위칭이므로 오버헤드가 적습니다. 
### 컨텍스트 스위칭이 발생할 때, 기존의 프로세스 정보는 커널스택에 어떠한 형식으로 저장되나요?
컨텍스트 스위칭 시에는 CPU가 실행 중인 프로세스의 실행 상태를 저장하는데, 이 정보는 각 프로세스에 할당된 **커널 스택**에 저장됩니다.
여기에는 **레지스터 값, 프로그램 카운터, 스택 포인터, 프로그램 상태 워드** 등이 포함됩니다.
- 리눅스에서는 **프로세스마다 고유의 커널 스택 (일반적으로 8KB)** 이 존재
- 사용자 모드에서 시스템 콜, 인터럽트, 예외로 커널 모드 진입 시, 해당 프로세스의 커널 스택을 사용
### 컨텍스트 스위칭은 언제 일어날까요?
- 선점형 스케줄링에서 타임 슬라이스 만료
- 인터럽트 처리 후 스케줄러 진입
- 시스템 콜에서 sleep/wait 블로킹
- yield(), pthread_yield() 호출 (명시적 양보)
- 종합) 선점 상태에서 더 높은 우선순위를 가진 프로세스가 cpu를 점유하려 할 때, 입출력 인터럽트가 발생할 수 있습니다. 

## 컨텍스트 스위칭 추가 공부 
### Q1. 커널 스택과 사용자 스택은 어떻게 분리되나요?
프로세스마다 사용자 스택과 별도로 커널 모드 진입 시 사용할 커널 스택이 존재합니다. 시스템 콜이나 인터럽트 발생 시 커널 모드로 전환되며, CPU는 자동으로 커널 스택을 기준으로 동작을 재개합니다. 이 구조 덕분에 커널은 사용자 영역의 오류로부터 안전성을 확보할 수 있습니다.
### Q2. 컨텍스트 스위칭 비용이 높은 이유는 무엇인가요?
저장하고 복원해야 할 정보가 많고, TLB 플러시로 인한 메모리 접근 속도 저하도 발생합니다. 특히 프로세스 간 스위칭은 **주소 공간 자체가 달라지므로 페이지 테이블도 교체**되고, **캐시 지역성**도 깨져 성능 저하로 이어집니다.
### Q3. 컨텍스트 스위칭 최소화를 위해 어떤 전략이 있을까요?
- 쓰레드 기반 동시성 구현 (컨텍스트 전환 비용이 낮음) == 여러 작업을 병렬 처리할 때, 각각을 프로세스가 아닌 스레드로 만
- CPU vs I/O 처리 시간 분리 및 효율적 스케줄링
- Coroutine, epoll/select 같은 비동기 이벤트 기반 처리
- User-level Thread 활용 (단, 다중 CPU 병렬성은 불가)
-----------
## 프로그램과 프로세스, 스레드의 차이에 대해 설명해 주세요.
- 프로그램 : 보조기억장치에 저장되어있는 정적인 모습
- 프로세스 : 프로그램이 실행되기 위해 메모리에 적재되는 단위
- 스레드 : 프로세스 안에서의 실행 흐름. 스레드끼리는 프로세스의 메모리 공간을 공유함

### PCB가 무엇인가요?
PCB는 **Process Control Block**의 약자로 **운영체제가 프로세스를 관리하기 위해 사용하는 데이터 구조**입니다. 구성으로는 **프로세스ID, 우선순위 레지스터 상태, 프로그램 카운터, 메모리 관리 정보** 등이 있습니다.
### 그렇다면, 스레드는 PCB를 갖고 있을까요?
스레드는 대부분 프로세스의 PCB를 공통적으로 가지고 있지만, **스택 포인터나 레지스터 정보** 등과 같은 스레드 별로 유지해야 하는 상태정보 구역은 새로 만들어서 가지고 있습니다. 이를 TCB라고 합니다.
- 동기화 처리, 더티 채킹, 레드락 (DB 동시성)
### 리눅스에서, 프로세스와 스레드는 각각 어떻게 생성될까요?
프로세스는 부모 프로세스로부터 **fork()** 받아 생성됩니다. 이로인해 부모와 똑같은 프로세스가 생성되고, 이후 **exec()** 를 통해 새 프로그램으로 실행이 가능한 상태가 됩니다.
스레드는 pthread_create()와 같은 **라이브러리**를 사용하여 생성됩니다. 스레드는 부모 프로세스의 주소 공간을 공유합니다.
### 자식 프로세스가 상태를 알리지 않고 죽거나, 부모 프로세스가 먼저 죽게 되면 어떻게 처리하나요?
자식 프로세스가 상태를 알리지 않고 죽으면 이는 좀비 프로세스로 남습니다. 좀비 프로세스는 cpu나 메모리를 소비하지는 않지만, 프로세스 테이블의 엔트리에는 남아있습니다.
부모 프로세스가 먼저 죽게 되면 고아 프로세스가 되어 최초 프로세스(init)이 그 프로세스를 수거하게 됩니다.
### 리눅스에서, 데몬 프로세스에 대해 설명해 주세요.
데몬 프로세스는 백그라운드에서 실행되며 사용자와 상호 작용하지 않는 프로세스를 말합니다.
### 리눅스는 프로세스가 일종의 트리를 형성하고 있습니다. 이 트리의 루트 노드에 위치하는 프로세스에 대해 설명해 주세요.
루트 노드는 systemd 라고도 불리는 최초의 프로세스입니다. 이는 시스템 부팅 시 생성되며 모든 노드의 부모 프로세스입니다. 

## 프로세스, 스레드 추가 공부 
### Q1. fork() vs exec()
fork()는 부모를 그대로 복사하는것이고, exec()는 현재 프로세스를 다른 프로그램 코드로 덮어쓰는 명령어입니다. 
fork() 후 exec()를 함께 사용하는 이유는 `fork()로 자식 생성 → exec()`로 자식이 원하는 프로그램 실행할 수 있기 때문입니다. 
- 이는 shell 구조, daemon 생성, 웹서버 프로세스 분기에서 자주 활용됩니다.
### Q2. 데몬 프로세스 생성 절차는 어떻게 되나요?
- fork() 호출 → 부모 종료
- 자식에서 setsid() 호출 → 세션 리더가 되어 터미널 분리
- chdir("/"), umask(0) 설정
- 표준 입출력 파일 디스크립터를 닫음
### Q3. 왜 fork() 후 부모를 종료시키나요?
자식이 init의 손자/자식으로 관리되게 하여 고아 프로세스가 init에 의해 회수되도록 하기 위해서입니다. 
### Q4. 왜 스레드는 TCB가 필요한가요? PCB 하나만으로 안 되나요?
PCB는 주소 공간, 파일 디스크립터 등 공유 리소스를 관리하지만, 스레드는 독립적인 실행 흐름을 가지기 때문에 개별적인 실행 컨텍스트 정보(레지스터, 스택 포인터 등)를 갖는 TCB가 필수입니다. 이를 통해 운영체제는 각 스레드를 올바르게 스케줄링할 수 있습니다.
### Q5. 부모 프로세스가 자식 프로세스를 wait() 하지 않으면 어떻게 되나요?
자식 프로세스가 종료되면 exit status를 부모에게 알리기 전까지 좀비 상태로 남습니다. 부모가 wait()을 호출하면 운영체제가 해당 상태를 수거합니다. 부모가 죽고 wait()을 안 한 경우, init 프로세스가 이 역할을 대신하게 됩니다.
### Q6. fork() 후 부모와 자식의 차이는 메모리 측면에서 어떻게 구분되나요?
처음엔 모든 메모리 공간이 복사되지 않고 공유되며, 이후 Copy-on-Write (COW) 기법으로 동작합니다. 어느 한쪽이 메모리를 수정하면 그 시점에 복사본이 생성되어 독립적인 공간이 마련됩니다. 이는 fork()의 성능 최적화에 중요합니다.


### 알아두면 좋을 리눅스 명령어 
명령어 | 설명
ps | 현재 실행 중인 프로세스 목록 조회
top / htop | 실시간 시스템 모니터링 (CPU, 메모리, PID 등)
pstree | 프로세스 간 부모-자식 관계를 트리 형태로 출력
pidof <프로그램> | 프로그램 이름으로 PID 확인
pgrep <조건> | 정규표현식 또는 조건 기반 프로세스 검색
`ps aux | grep <이름>`
strace -p <pid> | 해당 PID의 시스템 콜 추적
lsof -p <pid> | 특정 프로세스가 연 파일 목록 확인
cat /proc/<pid>/status | 프로세스 상세 상태 정보 확인 (커널 레벨)
nice, renice | 프로세스 우선순위 조절
kill, killall | 프로세스 종료

#### 추가 Q. ps와 top의 차이는 무엇인가요?
ps는 스냅샷처럼 한 시점의 프로세스 상태를 보여주는 명령어입니다. 반면, top은 주기적으로 정보를 갱신하여 실시간 리소스 사용 현황을 보여줍니다. 서버의 과부하 원인을 실시간으로 진단할 때 top이 유용합니다.
#### 추가 Q. 좀비 프로세스를 찾는 방법은?
`ps aux | awk '$8 == "Z"'`
- STAT 컬럼이 Z(zombie)인 프로세스를 필터링




-----------
[프로세스 3 보고 진행예정]
- Thread Safe 하다는 것은 어떤 의미인가요?
- Thread Safe 를 보장하기 위해 어떤 방법을 사용할 수 있나요?
- Peterson's Algorithm 이 무엇이며, 한계점에 대해 설명해 주세요.
- Race Condition 이 무엇인가요?
- Thread Safe를 구현하기 위해 반드시 락을 사용해야 할까요? 그렇지 않다면, 어떤 다른 방법이 있을까요?
- Thread Pool, Monitor, Fork-Join에 대해 설명해 주세요.
  Thread Pool을 사용한다고 가정하면, 어떤 기준으로 스레드의 수를 결정할 것인가요?
- 어떤 데이터를 정렬 하려고 합니다. 어떤 방식의 전략을 사용하는 것이 가장 안전하면서도 좋은 성능을 낼 수 있을까요?
